= Elixir Cheatsheet

[.sigils]
== link:https://elixir-lang.org/getting-started/sigils.html[Sigils]

Sigils support 8 different delimiters - `//`, `||`, `""`, `''`, `()`, `[]`, `{}`, `<>`.

[%autowidth, options="header"]
|=================
|Sigil |Explaination
|`~r()` |Regular Expression
|`~s()` |String (binary)
|`~c()` |Char list
|`~w()s` |Word list of strings (binaries)
|`~w()c` |Word list of char lists
|`~w()a` |Word list of atoms
|=================

[.escape-codes]
== link:https://elixir-lang.org/getting-started/sigils.html[Escape Codes]

The following escape codes can be used in strings and char lists:

[%autowidth, options="header"]
|=================
|Code |Explaination |Code |Explaination
|`\\` | single backslash |`\a` | bell/alert
|`\b` | backspace |`\d` | delete
|`\e` | escape |`\f` | form feed
|`\n` | newline |`\r` | carriage return
|`\s` | space |`\t` | tab
|`\v` | vertical tab |`\0` | null byte
|`\xDD` |represents a single byte in hexadecimal (such as \x13) |`\uDDDD` and `\u{D...}` |represents a Unicode codepoint in hexadecimal (such as \u{1F600})
|=================

A double quote literal inside a double quoted string also needs to be escaped.

[.metaprogramming]
== link:https://elixir-lang.org/getting-started/meta/macros.html[Metaprogramming]

Various metaprogramming variables and macros.
[%autowidth, options="header"]
|=================
|Expression |Explaination
|`__ENV__` |A struct containing details about the compilation environment
|`defmacro (name) do ... end` |Define a macro
|`quote do ... end` |Convert the code inside the block to AST
|`unquote(expresion)` |Use to inject values from outside of the `quote` block
|`def __using__` |The using macro
|`\_\_MODULE\_\_` |Expands to the module name of the current module
|`__CALLER__` |
|`__DIR__` |
|`__STACKTRACE__` |
|=================

== Structs, Maps, and Lists

[%autowidth, options="header"]
|=================
|Operation |List |Map |Struct
|Create |`[1,2,3]` |`%{a: :foo}` |
|Pattern match | | |
|=================

----
defmodule Person do
  defstruct first_name: "", last_name: ""
end
----

Create

`%Person{first_name: "Trevor", last_name: "Brown"}`

Pattern match


Get field value
Update

== 

[

[.comprehensions]
== Comprehensions

[source, elixir]
----
for var1 <- generator1,
    var2 <- generator2,
    new_var = some_expr(var1, var2,
    a_check?(new_var) do
    operation_to_generate_final_value(var1, var2)
end
----

[[footer]]
[.credit]
http://erlang.org/doc/design_principles/des_princ.html[OTP Design Principles]  Created by https://stratus3d.com[Stratus3D]  Copyright 2018.  https://github.com/Stratus3D/erlang-cheatsheet[Source Code]
